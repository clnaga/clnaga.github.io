---
layout: mypost
title: 网络
categories: [Java]
---



### HTTP 响应码有哪些？分别代表什么含义？

- 200：成功，Web 服务器成功处理了客户端的请求
- 301：永久重定向，当客户端请求一个网址的时候，Web 服务器会将当前请求重定向到另一个网址，搜索引擎会抓取重定向后网页的内容并且将旧的网址替换为重定向后的网址
- 302：临时重定向，搜索引擎会抓取重定向后网页的内容而保留旧的网址，因为搜索引擎认为重定向后的网址是暂时的
- 400：客户端请求错误，多为参数不合法导致 Web 服务器验参失败
- 404：未找到，Web 服务器找不到资源
- 500：Web 服务器错误，服务器处理客户端请求的时候发生错误
- 503：服务不可用，服务器停机
- 504：网关超时

### forward 和 redirect 的区别？

Forward和Redirect代表了两种请求转发方式：直接转发和间接转发。

直接转发方式（Forward），客户端和浏览器只发出一次请求，Servlet、HTML、JSP或其它信息资源，由第二个信息资源响应该请求，在请求对象request中，保存的对象对于每个信息资源是共享的。

间接转发方式（Redirect）实际是两次HTTP请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个URL发出请求，从而达到转发的目的。

### GET 和 POST 请求有哪些区别？

1. 用途：
   + get 请求用来从服务器获取资源 
   + post 请求用来向服务器提交数据 
2. 表单的提交方式：
   + get 请求直接将表单数据以 name1=value1&name2=value2 的形式拼接到 URL 上，多个参数参数值需要用 & 连接起来并且用 ? 拼接到 action 后面； 
   + post 请求将表单数据放到请求头或者请求的消息体中。 
3. 传输数据的大小限制： 
   + get 请求传输的数据受到 URL 长度的限制，而 URL 长度是由浏览器决定的； 
   + post 请求传输数据的大小理论上来说是没有限制的。
4. 参数的编码：
   + get 请求的参数会在地址栏明文显示，使用 URL 编码的文本格式传递参数； 
   + post 请求使用二进制数据多重编码传递参数。
5. 缓存：
   + get 请求可以被浏览器缓存被收藏为标签； 
   + post 请求不会被缓存也不能被收藏为标签。

### 简述 tcp 和 udp的区别？

- TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接。
- TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。
- TCP通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。
- UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。
- 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信。
- TCP对系统资源要求较多，UDP对系统资源要求较少。
- TCP 传输数据基于字节流；UDP 是基于数据报传输数据的

###  tcp 为什么要三次握手，两次不行吗？为什么？

为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤。

如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。

### 说一下 tcp 粘包是怎么产生的？

**发送方产生粘包：**

采用TCP协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据；但当发送的数据包过于的小时，那么TCP协议默认的会启用Nagle算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。

<img src="粘包1.jpg" alt="粘包1" style="zoom:67%;" />

**接收方产生粘包：**

接收方采用TCP协议接收数据时的过程是这样的：数据到达接收方，从网络模型的下方传递至传输层，传输层的TCP协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C语言用recv、read等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（放数据的速度 > 应用层拿数据速度） 

<img src="粘包2.jpg" alt="粘包2" style="zoom: 50%;" />

**造成粘包和拆包现象的原因：**

+ TCP 发送缓冲区剩余空间不足以发送一个完整的数据包，将发生拆包； 
+ 要发送的数据超过了最大报文长度的限制，TCP 传输数据时进行拆包；
+ 要发送的数据包小于 TCP 发送缓冲区剩余空间，TCP 将多个数据包写满发送缓冲区一次发送出去，将发生粘包； 
+ 接收端没有及时读取 TCP 发送缓冲区中的数据包，将会发生粘包。

**粘包拆包的解决方法：**

+ 发送端给数据包添加首部，首部中添加数据包的长度属性，这样接收端通过首部中的长度字段就可以知道数据包的实际长度啦；
+ 针对发送的数据包小于缓冲区大小的情况，发送端可以将不同的数据包规定成同样的长度，不足这个长度的补充 0，接收端从缓冲区读取固定的长度数据这样就可以区分不同的数据包； 
+ 发送端通过给不同的数据包添加间隔符合确定边界，接收端通过这个间隔符合就可以区分不同的数据包。

### TCP 如何保证可靠性

+ **序列号和确认号机制：**
  TCP 发送端发送数据包的时候会选择一个 seq 序列号，接收端收到数据包后会检测数据包的完整性，如果检测通过会响应一个 ack 确认号表示收到了数据包。 

+ **超时重发机制：**
  TCP 发送端发送了数据包后会启动一个定时器，如果一定时间没有收到接受端的确认后，将会重新发送该数据包。

+ **对乱序数据包重新排序：** 

  从 IP 网络层传输到 TCP 层的数据包可能会乱序，TCP 层会对数据包重新排序再发给应用层。 

+ **丢弃重复数据：**

  从 IP 网络层传输到 TCP 层的数据包可能会重复，TCP 层会丢弃重复的数据包。 

+ **流量控制：**
  TCP 发送端和接收端都有一个固定大小的缓冲空间，为了防止发送端发送数据的速度太快导致接收端缓冲区溢出，发送端只能发送接收端可以接纳的数据，为了达到这种控制效果，TCP 用了流量控制协议（可变大小的滑动窗口协议）来实现。

### OSI 的七层模型都有哪些？

1. 应用层：网络服务与最终用户的一个接口。
2. 表示层：数据的表示、安全、压缩。
3. 会话层：建立、管理、终止会话。
4. 传输层：定义传输数据的协议端口号，以及流控和差错校验。
5. 网络层：进行逻辑地址寻址，实现不同网络之间的路径选择。
6. 数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能。
7. 物理层：建立、维护、断开物理连接。

### 浏览器中输入：“www.woaijava.com”之后都发生了什么？ 请详细阐述

1. 由域名→IP地址 寻找IP地址的过程依次经过了浏览器缓存、系统缓存、hosts文件、路由器缓 存、 递归搜索根域名服务器。 
2. 建立TCP/IP连接（三次握手具体过程） 
3. 由浏览器发送一个HTTP请求
4. 经过路由器的转发，通过服务器的防火墙，该HTTP请求到达了服务器 
5. 服务器处理该HTTP请求，返回一个HTML文件 
6. 浏览器解析该HTML文件，并且显示在浏览器端 

这里需要注意： 

+ HTTP协议是一种基于TCP/IP的应用层协议，进行HTTP数据请求必须先建立TCP/IP连接 可以这样理解：HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了 网络通信的能力。
+ 两个计算机之间的交流无非是两个端口之间的数据通信,具体的数据会以什么样的形式展现是以不同的应用层协议来定义的。

### 说说HTTP协议与TCP/IP协议的关系

HTTP的长连接和短连接本质上是TCP长连接和短连接。 

HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。 

IP协议主要解决网络路由和寻址问题，

TCP协议主要解决如何在IP层之上可靠地传递数据包，使得网络上接收端收到发送端所发出的所有包，并且顺序与发送顺序一致。TCP协议是可靠的、面向连接的。

### 说一下 session 的工作原理？

其实session是一个存在服务器上的类似于一个散列表格的文件。里面存有我们需要的信息，在我们需要用的时候可以从里面取出来。类似于一个大号的map吧，里面的键存储的是用户的sessionid，用户向服务器发送请求的时候会带上这个sessionid。这时就可以从中取出对应的值了。

### 如果客户端禁止 cookie 能实现 session 还能用吗？

Cookie与 Session，一般认为是两个独立的东西，Session采用的是在服务器端保持状态的方案，而Cookie采用的是在客户端保持状态的方案。但为什么禁用Cookie就不能得到Session呢？因为Session是用Session ID来确定当前对话所对应的服务器Session，而Session ID是通过Cookie来传递的，禁用Cookie相当于失去了Session ID，也就得不到Session了。

> Reference:
>
> + https://mp.weixin.qq.com/s/F201iO7TQNkZz8yAh3PILg
> + [HTTP消息- HTTP | MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Messages)

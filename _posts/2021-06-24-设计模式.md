---
layout: mypost
title: 设计模式
categories: [Java]
---



### 说一下你熟悉的设计模式？

#### 单例模式

**单例模式：**就是一个应用程序中，某个类的实例对象只有一个，你没有办法去new，因为构造器是被private修饰的，一般通过getInstance()的方法来获取它们的实例。

```java
// 懒汉式
public class Singleton {
	private static Singleton instance;
    private Singleton() {}
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
// 线程安全懒汉式
public class Singleton {
	private static Singleton instance;
    private Singleton() {}
    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
// DCL (Double-checked Locking, 双重检查锁定模式)
public class Singleton {
	private static Singleton instance;
    private Singleton() {}
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
/*
* 在执行 instance = new Singleton() 时还是有安全问题，JVM 在执行改行代码时会进行分配对象的内存空间、初始化对象、instance 引用分配好的空间，但指令重排后，有可能出现的情况是初始化对象和 instance 引用两条指令交换，导致 instance 引用到未初始化的对象。如果此时刚好有线程访问，那么会直接返回一个未初始化的对象，从而导致线程安全问题的出现。
* 解决方法就是加 volatile 关键字，防止指令重排就好了。
*/

// 静态内部类
public class Singleton {
    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }
    private Singleton() {}
    public static synchronized Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
// 饿汉式
public class Singleton {
	private static Singleton instance = new Singleton();
    private Singleton() {}
    public static Singleton getInstance() {
        return instance;
    }
}
// 枚举类：上面几种方法序列化和反序列化会重新创建单例实例，而枚举l
// https://segmentfault.com/a/1190000024472352
```

#### 观察者模式

**观察者模式：**对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

```java
public interface Person {
    // 小王和小李可以通过这个接口接受小美发来的消息
    void getMessage(String s)
}
public class XiaoWang implements Person {
    private String name = "小王";
    public XiaoWang() {}
    @Override
    public void getMessage(String s) {
        System.out.println(name + "接到了小美打过来的电话，电话内容是：" + s);
    }
}
public class XiaoLi implements Person {
    private String name = "小李";
    public XiaoLi() {}
    @Override
    public void getMessage(String s) {
        System.out.println(name + "接到了小美打过来的电话，电话内容是：-->" + s);
    }
}
public class XiaoMei {
    List<Person> list = new ArrayList<Person>();
    public XiaoMei() {}
    public void addPerson(Person person) {
        list.add(person);
    }
    // 发消息给备胎
    public void notifyPerson() {
        for (Person person : list) {
            person.getMessage("你们过来吧，谁先过来谁就能陪我一起玩儿游戏!");
        }
    }
}
public class Test {
   public static void main(String[] args) {
       XiaoMei xiaoMei = new XiaoMei();
       LaoWang xiaoWang = new XiaoWang();
       LaoLi xiaoLi = new XiaoLi();
       //小王和小李在小美那里都注册了一下
       xiaoMei.addPerson(xiaoWang);
       xiaoMei.addPerson(xiaoLi);
       //小美向小王和小李发送通知
       xiaoMei.notifyPerson();
   }
}
```

#### 装饰者模式

**装饰者模式：**对已有的业务逻辑进一步的封装，使其增加额外的功能，如Java中的IO流就使用了装饰者模式，用户在使用的时候，可以任意组装，达到自己想要的效果。

```java
public class Food {
    private String foodName;
    public Food() {}
    public Food(String foodName) {
        this.foodName = foodName;
    }
    public String make() {
        return foodName;
    }
}
// 面包类
public class Bread extends Food {
    private Food basicFood;
    public Bread(Food basicFood) {
        this.basicFood = basicFood;
    }
    public String make() {
        return basicFood.make() + "+面包";
    }
}
// 奶油类
public class Cream extends Food {
    private Food basicFood;
    public Cream(Food basicFood) {
        this.basicFood = basicFood;
    }
    public String make() {
        return basicFood.make() + "+奶油";
    }
}
public class Test {
   public static void main(String[] args) {
       Food food = new Bread(new Cream(new Food("香肠")));
       System.out.println(food.make());
   }
}
```

#### 适配者模式

**适配器模式：**将两种完全不同的事物联系到一起，就像现实生活中的变压器。假设一个手机充电器需要的电压是20V，但是正常的电压是220V，这时候就需要一个变压器，将220V的电压转换成20V的电压，这样，变压器就将20V的电压和手机联系起来了。

```java
class Phone {
    public static final int V = 220;
    private VoltageAdapter adapter;
    public void charge() {
        adapter.changeVoltage();
    }
    public void setAdapter(VoltageAdapter adapter) {
        this.adapter = adapter;
    }
}
// 变压器
class VoltageAdapter {
    public void changeVoltage() {
       System.out.println("正在充电...");
       System.out.println("原始电压：" + Phone.V + "V");
       System.out.println("经过变压器转换之后的电压:" + (Phone.V - 200) + "V");
    }
}
public class Test {
    public static void main(String[] args) {
        Phone phone = new Phone();
        VoltageAdapter adapter = new VoltageAdapter();
        phone.setAdapter(adapter);
        phone.charge();
    }
}
```

#### 工厂模式

**工厂模式：**

简单工厂模式：一个抽象的接口，多个抽象接口的实现类，一个工厂类，用来实例化抽象的接口

```java
// 抽象产品类
abstract class Car {
    public void run();
    public void stop();
}
// 具体实现类
class Benz implement Car {
    @Override
    public void run() {
        System.out.println("Benz开始启动了。。。。。");
    }
    @Override
    public void stop() {
        System.out.println("Benz停车了。。。。。");
    }
}
class Ford implement Car {
    @Override
    public void run() {
        System.out.println("Ford开始启动了。。。。。");
    }
    @Override
    public void stop() {
        System.out.println("Ford停车了。。。。。");
    }
}
// 工厂类
class Factory {
    public static Car getCarInstance(String type) {
        Car car = null;
        if ("Benz".equals(type)) {
            car = new Benz();
        } else if ("Ford".equals(type)) {
            car = new Ford();
        }
        return car;
    }
}
public class Test {
    public static void main(String[] args) {
        Car car = Factory.getCarInstance("Benz");
        if (car != null) {
            car.run();
            car.stop();
        } else {
           System.out.println("造不了这种汽车。。。");
        }
    }
}
```

工厂方法模式：有四个角色，抽象工厂，具体工厂，抽象产品，具体产品。不再是由一个工厂类去实例化具体的产品，而是由抽象工厂的子类去实例化产品

```java
// 抽象产品
public interface Moveable {
    void run();
}
// 具体产品
public class Plane implements Movable {
    @Override
    public void run() {
        System.out.println("plane....");
    }
}
public class Broom implements Movable {
    @Override
    public void run() {
        System.out.println("broom....");
    }
}
// 抽象工厂
public abstract class VehicleFactory {
    abstract Moveable create();
}
// 具体工厂
public class PlaneFactory extends VehicleFactory {
    public Moveable create() {
        return new Plane();
    }
}
public class BroomFactory extends VehicleFactory {
    public Moveable create() {
        return new Broom();
    }
}
// 测试类
public class Test {
    public static void main(String[] args) {
        VehicleFactory factory = new BroomFactory();
        Moveable moveable = factory.create();
        moveable.run();
    }
}
```

抽象工厂模式：与工厂方法模式不同的是，工厂方法模式中的工厂只生产单一的产品，而抽象工厂模式中的工厂生产多个产品

```java
// 抽象工厂类
public abstract class AbstractFactory {
    public abstract Vehicle createVehicle();
    public abstract Weapon createWeapon();
    public abstract Food createFood();
}
// 具体工厂类
public class DefaultFactory extends AbstractFactory {
    @Override
    public Vehicle createVehicle() {
        return new Car();
    }
    @Override
    public Weapon createWeapon() {
        return new AK47();
    }
    @Override
    public Food createFood() {
        return new Apple();
    }
}
// Test
public class Test {
    public static void main(String[] args) {
        AbstractFactory f = new DefaultFactory();
        Vehicle vehicle = f.createVehicle();
        vehicle.run();
    }
}
```

#### 代理模式

**代理模式（proxy）：**

```java
//代理接口
public interface ProxyInterface {
	//需要代理的是结婚这件事
	void marry();
}
// 婚庆公司
public class WeddingCompany implements ProxyInterface {
    private ProxyInterface proxyInterface;
    public WeddingCompany(ProxyInterface proxyInterface) {
        this.proxyInterface = proxyInterface;
    }
    @Override
    public void marry() {
        System.out.println("我们是婚庆公司的");
        System.out.println("我们在做结婚前的准备工作");
        System.out.println("节目彩排...");
        System.out.println("礼物购买...");
        System.out.println("工作人员分工...");
        System.out.println("可以开始结婚了");
        proxyInterface.marry();
        System.out.println("结婚完毕，我们需要做后续处理，你们可以回家了，其余的事情我们公司来做");
    }
}
// 结婚家庭
public class NormalHome implements ProxyInterface {
    @Override
    public void marry() {
        System.out.println("我们结婚啦～");
    }
}
// Test
public class Test {
    public static void main(String[] args) {
        ProxyInterface proxyInterface = new WeddingCompany(new NormalHome());
        proxyInterface.marry();
    }
}
```

### 适配器模式，装饰模式，代理模式异同

**适配器的特点在于兼容**，从代码上的特点来说，适配类与原有的类具有相同的接口，并且持有新的目标对象。就如同一个三孔转2孔的适配器一样，他有三孔的插头，可以插到三孔插座里，又有两孔的插座可以被2孔插头插入。适配器模式是在于对原有3孔的改造。在使用适配器模式的时候，我们必须同时持有原对象，适配对象，目标对象。。。。

**装饰器模式特点在于增强**，他的特点是被装饰类和所有的装饰类必须实现同一个接口，而且必须持有被装饰的对象，可以无限装饰。

**代理模式的特点在于隔离**，隔离调用类和被调用类的关系，通过一个代理类去调用。

总的来说就是如下三句话：

- 适配器模式是将一个类(a)通过某种方式转换成另一个类(b).
- 装饰模式是在一个原有类(a)的基础之上增加了某些新的功能变成另一个类(b).
- 代理模式是将一个类(a)转换成具体的操作类(b).

> https://www.jianshu.com/p/c156b5e23e30

### 图说设计模式

https://design-patterns.readthedocs.io/zh_CN/latest/index.html

> Reference:
>
> + https://mp.weixin.qq.com/s/Wahq4TnCm4Pzb6VshWma1Q
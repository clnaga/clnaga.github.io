---
layout: mypost
title: MySQL
categories: [Java]
---



### 数据库的三范式是什么？

- 第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。
- 第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。
- 第三范式：任何非主属性不依赖于其它非主属性。

### 一张自增表里面总共有 17 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几？

- 表类型如果是 MyISAM ，那 id 就是 18。
- 表类型如果是 InnoDB，那 id 就是 15。

InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失。

### char 和 varchar 的区别是什么？

char(n) ：固定长度类型，比如订阅 char(10)，当你输入"abc"三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。

char 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。

varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。

所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。

### float 和 double 的区别是什么？

- float 最多可以存储 8 位的十进制数，并在内存中占 4 字节。
- double 最可可以存储 16 位的十进制数，并在内存中占 8 字节。

### MySQL 的内连接、左连接、右连接有什么区别？

内连接关键字：inner join；左连接：left join；右连接：right join。

内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。

https://blog.csdn.net/weixin_39220472/article/details/81193617

### 索引的基本原理

+ 索引用来快速的寻找那些具有特定值的记录，如果没有索引，一般来说执行查询时遍历整张表
+ 索引的原理：把无序的数据变成有序的查询
  1. 把创建了索引的列的内容进行排序
  2. 对排序结果生成倒排序
  3. 在倒排序内容上拼上数据地址链
  4. 在查询的时候，先拿到倒排表内容，在取出数据地址链，从而拿到具体数据

### MySQL 索引有哪些

**按数据结构分类可分为：**B+tree索引、Hash索引、Full-text索引。
**按物理存储分类可分为：**聚簇索引**、**二级索引（辅助索引）。

> [MySQL索引有哪些分类](https://segmentfault.com/a/1190000037683781)

### MySQL 聚簇索引和非聚簇索引区别

都是 B+ 树结构

**区别：**

+ 聚簇索引：将数据存储与索引放在一起，并且按照一定的顺序组织，找到索引也就找到了数据，数据的物理存放顺序与索引顺序时一致的
+ 非聚簇索引：叶子节点不存储数据，存储的是主键和数据行地址，也就是说根据索引查找到数据行的位置再去磁盘查找数据
+ InnoDB 一定有主键，主键一定是聚簇索引，MyISAM 使用的是非聚簇索引

**聚簇索引优点：**

1. 查询通过聚簇索引可以直接获取数据，相比非聚簇索引需要二次查询（非覆盖索引的情况下）效率更高
2. 聚簇索引对于范围查询的效率更高，因为数据是按照大小排列的
3. 聚簇索引适合排序场合，非聚簇索引不适合

**聚簇索引缺点：**

1. 维护索引费用昂贵
2. 表使用 UUID（随机 ID）作为主键，使数据存储稀疏，这会出现聚簇索引有可能比全表扫描更慢，索引建议使用 int 的 auto_increment 作为主键
3. 如果主键比较大，辅助索引也会变得更大，因为辅助索引的叶子存储的是主键值；过长的主键值会导致叶子节点占用更多的物理空间

### MySQL 索引的数据结构

索引的数据结构和具体存储引擎的实现有关，再 MySql 中使用较多的是 Hash 索引和 B+ 树索引。InnoDB存储引擎默认索引实现是 B+ 树索引。对于 Hash 索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择 Hash 索引，查询性能最快；其余大部分场景，建议选择 B+ 树索引

+ B+ 树索引：是一个平衡的多叉树，且叶子节点间有双链指针相互连接。在 B+ 树上常规检索，从根节点到叶子节点搜索效率基本相当，而且基于索引的顺序扫描时，也可以利用双向指针快速左右移动，效率非常高，因此，B+ 树索引广泛应用于数据库、文件系统等场景
+ Hash 索引：采用一定的哈希算法，把键值换成新的哈希值，只需一次哈希算法即可定位到相应位置。只适合等值查询，不适合范围查询

### MySQL 索引是怎么实现的？

索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。

具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。

### 怎么验证 MySQL 的索引是否满足需求？

使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。

explain 语法：explain select * from table where type=1。

### 说一下 MySQL 常用的引擎？

InnoDB 引擎：InnoDB 引擎提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。

MyIASM 引擎：MySQL 的默认引擎，但不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。

### MySQL 事务隔离级别，默认隔离级别，为什么这么选

**四个隔离级别：**

+ READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
+ READ**-**COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
+ REPEATABLE**-**READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
+ SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。

**默认隔离级别：**

InnoDB 存储引擎在 REPEATABLE-READ（可重读），事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如SQL Server) 是不同的。

所以说InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）
已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 SERIALIZABLE(可串行化) 隔离级别。

**为什么会默认可重复读：**

考虑 MySQL 的主从同步，隔离级别设为可重复读(Repeatable Read)，在该隔离级别下引入间隙锁，实现了写入 Binlog 的语句串行化。解决了主从不一致的问题。

### 脏读、不可重复读、幻读

+ 脏读（读取未提交数据）：A事务读取B事务尚未提交的数据，此时如果B事务发生错误并执行回滚操作，那么A事务读取到的数据就是脏数据。
+ 不可重复读（前后多次读取，数据内容不一致）：事务A在执行读取操作，由整个事务A比较大，前后读取同一条数据需要经历很长的时间 。而在事务A第一次读取数据，比如此时读取了小明的年龄为20岁，事务B执行更改操作，将小明的年龄更改为30岁，此时事务A第二次读取到小明的年龄时，发现其年龄是30岁，和之前的数据不一样了，也就是数据不重复了，系统不可以读取到重复的数据，成为不可重复读。**（注重数据的内容，错误发生在 update，解决方法是加行级锁）**
+ 幻读（前后多次读取，数据总量不一致）：事务A在执行读取操作，需要两次统计数据的总量，前一次查询数据总量后，此时事务B执行了新增数据的操作并提交后，这个时候事务A读取的数据总量和之前统计的不一样，就像产生了幻觉一样，平白无故的多了几条数据，成为幻读。**（注重数据的数量，错误发生在 insert 和 delete，解决方法是加表级锁、临建锁）**

> [快速理解脏读、不可重复读、幻读和MVCC - 云+社区- 腾讯云](https://cloud.tencent.com/developer/article/1450773)

### 说一下 ACID 是什么？

- Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。
- Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。
- Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。
- Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

### 说一下 MySQL 的行锁和表锁？

MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。

- 表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。
- 行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。

### 说一下乐观锁和悲观锁？

- 乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。
- 悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。

数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。

### 什么是 MVCC？

英文全称为Multi-Version Concurrency Control，乐观锁为理论基础的MVCC（多版本并发控制），MVCC的实现没有固定的规范。每个数据库都会有不同的实现方式。

MVCC 手段只适用于 MySQL 隔离级别中的读已提交和可重复读，而读未提交由于存在脏读，即能读到未提交事务的数据行，所以不适用 MVCC。原因是 MVCC 的创建版本和删除版本只要在事务提交后才会产生。串行化由于是会对所涉及到的表加锁，并非行锁，自然也就不存在行的版本控制问题。

通过以上总结，可知，MVCC 主要作用于事务性的，有行锁控制的数据库模型。

> [快速理解脏读、不可重复读、幻读和MVCC - 云+社区- 腾讯云](https://cloud.tencent.com/developer/article/1450773)

### MySQL 主从同步原理

+ MySQL 主从同步过程

  MySQL 的主从同步中，只要有三个线程，master（binlog dump thread）、slave（I/O thread、SQL thread）

  1. 主节点 binlog：主从同步的基础时主库记录数据库的所有变更记录到 binlog 中。binlog 是数据库服务器启动的那一刻起，保存所有修改数据库结构或内容操作的一个文件
  2. 主节点 log dump 线程：当 binlog 有变动时，log dump 线程读取其内容并发送给从节点
  3. 从节点 I/O 线程接受 binlog 内容，将其写入 relay log 文件中
  4. 从节点的 SQL 线程读取 relay log 文件内容对数据更新进行重放，最终保证主从数据库的一致性

  注：主从节点使用 binlog 文件 + position 偏移量来定位主从同步的位置，从节点会保存已接受到的偏移量，如果从节点发生宕机重启，则会自动从position 位置发起同步

  <img src="MySQL主从同步.png" alt="MySQL主从同步" style="zoom: 50%;" />

+ 由于 MySQL 默认的复制方式是异步的，主库把日志发送给从库就不关心从库是否处理，这样如果主库挂了，从库处理失败，这时从库升级为主库会造成日志丢失，从而产生两个概念：

  + 全同步复制：主库写入 binlog 后强制同步日志到从库，所有从库都执行完成后才返回客户端，性能受影响
  + 半同步复制：从库写入日志成功后返回 ACK 确认给主库，主库至少收到一个从库的确认就可认为写操作完成（多少个从库确认可自己设置）

### 如何做 MySQL 的性能优化？

- 为搜索字段创建索引。
- 避免使用 select *，列出需要查询的字段。
- 垂直分割分表。
- 选择正确的存储引擎。

> Reference:
>
> + https://mp.weixin.qq.com/s/BXSfeO1B_uaPy2tSdEvp-A
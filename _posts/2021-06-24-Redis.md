---
layout: mypost
title: Redis
categories: [Java]
---



### Redis 是什么？都有哪些使用场景？

Redis 是一个开源的、基于内存、支持多种数据结构的存储系统，是个可持久化的日志型、Key-Value数据库，并提供多种语言的API，也可以作为缓存和消息中间件。

它支持的数据结构有字符串（strings）、哈希（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）等，除此之外还支持 bitmaps、hyperloglogs 和地理空间（ geospatial ）索引半径查询等功能。

Redis 使用场景：

- 数据高并发的读写
- 海量数据的读写
- 对扩展性要求高的数据

### Redis 有哪些功能？

- 数据缓存功能
- 分布式锁的功能
- 支持数据持久化
- 支持事务
- 支持消息队列

### Redis 数据类型及底层实现

> [图解redis五种数据结构底层实现](https://i6448038.github.io/2019/12/01/redis-data-struct/){:target="_blank"}

### Redis 的架构及应用实践

1. 持久化
2. 主从
3. 哨兵
4. 集群

> [Redis架构原理及应用实践](https://www.jianshu.com/p/6c970eb652d5){:target="_blank"}

### Redis 和 memecache 有什么区别？

- memcached 所有的值均是简单的字符串，Redis作为其替代者，支持更为丰富的数据类型
- Redis 的速度比 memcached 快很多
- 存储数据安全– Memcache 挂掉后，数据没了； Redis 可以定期保存到磁盘（持久化）
- 灾难恢复– Memcache 挂掉后，数据不可恢复; Redis 数据丢失后可以通过 AOF 恢复

### Redis 为什么是单线程的？

因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。

关于 Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。

而且单线程并不代表就慢 nginx 和 nodejs 也都是高性能单线程的代表。

### 为什么Redis单线程模型效率也能那么高？

+ C语言实现，效率高 
+ 纯内存操作 
+ 基于非阻塞的IO复用模型机制 
+ 单线程的话就能避免多线程的频繁上下文切换问题 
+ 丰富的数据结构（全称采用hash结构，读取速度非常快，对数据存储进行了一些优化，比如压缩表，跳表等）

> [Redis为什么这么快](https://segmentfault.com/a/1190000022088928){:target="_blank"}

### 压缩表为什么可以节省内存

`ziplist` 虽然不维护前后节点的指针，但是它却维护了上一个节点的长度和当前节点的长度，然后每次通过长度来计算出前后节点的位置。

而在 `Redis` 中，一个指针是占了 `8` 个字节，但是大部分情况下，如果直接存储长度是达不到 `8` 个字节的，所以采用存储长度的设计方式在大部分场景下是可以节省内存空间的。

> [牺牲速度来节省内存，Redis是觉得自己太快了吗](https://zhuanlan.zhihu.com/p/344458785){:target="_blank"}

### Redis 有什么优点和缺点

+ 优点
  1. 速度快：因为数据存在内存中，类似于 HashMap ，HashMap 的优势就是查找和操作的时间复杂度都是O (1) 。
  
  2. 支持丰富的数据结构：支持 String ，List，Set，ZSet，Hash 五种基础的数据结构。
  
     > [Redis SDS的原理及与C字符串比较](https://codeleading.com/article/35214721883/){:target="_blank"}
     >
     > [C++中string类和Redis中SDS的比较](https://blog.csdn.net/wrx1721267632/article/details/50962370){:target="_blank"}
     >
     > [redis渐进式rehash机制](https://luoming1224.github.io/2018/11/12/[redis学习笔记]redis渐进式rehash机制/){:target="_blank"}
  
  3. 持久化存储：Redis 提供 RDB 和 AOF 两种数据的持久化存储方案，解决内存数据库最担心的万一 Redis 挂掉，数据会消失掉 
  
  4. 高可用：内置 Redis 哨兵，提供高可用方案，实现主从故障自动转移。 内置 Redis Cluster，提供集群方案，实现基于槽的分片方案，从而支持更大的 Redis 规模。 
  
  5. 丰富的特性：Key过期、计数、分布式锁、消息队列等。
+ 缺点
  1. 由于 Redis 是内存数据库，所以，单台机器，存储的数据量，跟机器本身的内存大小。虽然 Redis 本身有 Key 过期策略，但是还是需要提前预估和节约内存。如果内存增长过快，需要定期删除数据。
  2. 如果进行完整重同步，由于需要生成 RDB 文件，并进行传输，会占用主机的 CPU ，并会消耗现网的带宽。不过 Redis 2.8 版本，已经有部分重同步的功能，但是还是有可能有完整重同步的。比如，新上线的备机。
  3. 修改配置文件，进行重启，将硬盘中的数据加载进内存，时间比较久。在这个过程中， Redis 不能提供服务。

### 介绍下 Redis 集群 

集群有三种模式：主从复制模式、哨兵模式、Cluster 模式

**主从复制模式：**

<img src="Redis集群主从复制.png" alt="Redis集群主从复制" style="zoom: 50%;" />

主从复制作用：

+ 一个是读写分离，分担 “master” 的读写压力
+ 一个是方便做容灾回复

> 通过持久化功能，Redis保证了即使在服务器重启的情况下也不会丢失（或少量丢失）数据，因为持久化会把内存中数据保存到硬盘上，重启会从硬盘上加载数据。 但是由于数据是存储在一台服务器上的，如果这台服务器出现硬盘故障等问题，也会导致数据丢失。
>
> 为了避免单点故障，通常的做法是将数据库复制多个副本以部署在不同的服务器上，这样即使有一台服务器出现故障，其他服务器依然可以继续提供服务。
>
> 为此， Redis 提供了复制（replication）功能，可以实现当一台数据库中的数据更新后，自动将更新的数据同步到其他数据库上。
>
> 在复制的概念中，数据库分为两类，一类是主数据库（master），另一类是从数据库(slave）。主数据库可以进行读写操作，当写操作导致数据变化时会自动将数据同步给从数据库。而从数据库一般是只读的，并接受主数据库同步过来的数据。一个主数据库可以拥有多个从数据库，而一个从数据库只能拥有一个主数据库。

主从复制原理：

<img src="Redis集群主从复制原理.png" alt="Redis集群主从复制原理" style="zoom: 50%;" />

> - 从数据库启动成功后，连接主数据库，发送 SYNC 命令；
> - 主数据库接收到 SYNC 命令后，开始执行 BGSAVE 命令生成 RDB 文件并使用缓冲区记录此后执行的所有写命令；
> - 主数据库 BGSAVE 执行完后，向所有从数据库发送快照文件，并在发送期间继续记录被执行的写命令；
> - 从数据库收到快照文件后丢弃所有旧数据，载入收到的快照；
> - 主数据库快照发送完毕后开始向从数据库发送缓冲区中的写命令；
> - 从数据库完成对快照的载入，开始接收命令请求，并执行来自主数据库缓冲区的写命令；（**从数据库初始化完成**）
> - 主数据库每执行一个写命令就会向从数据库发送相同的写命令，从数据库接收并执行收到的写命令（**从数据库初始化完成后的操作**）
> - 出现断开重连后，2.8之后的版本会将断线期间的命令传给重数据库，增量复制。
> - 主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。Redis 的策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。

主从复制优缺点：

优点：

+ 支持主从复制，主机会自动将数据同步到从机，可以进行读写分离；
+ 为了分载 Master 的读操作压力，Slave 服务器可以为客户端提供只读操作的服务，写服务仍然必须由Master来完成；
+ Slave 同样可以接受其它 Slaves 的连接和同步请求，这样可以有效的分载 Master 的同步压力；
+ Master Server 是以非阻塞的方式为 Slaves 提供服务。所以在 Master-Slave 同步期间，客户端仍然可以提交查询或修改请求；
+ Slave Server 同样是以非阻塞的方式完成数据同步。在同步期间，如果有客户端提交查询请求，Redis则返回同步之前的数据；

缺点：

- Redis不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复（**也就是要人工介入**）；
- 主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性；
- 如果多个 Slave 断线了，需要重启的时候，尽量不要在同一时间段进行重启。因为只要 Slave 启动，就会发送sync 请求和主机全量同步，当多个 Slave 重启的时候，可能会导致 Master IO 剧增从而宕机。
- Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂；

**Sentinel（哨兵）模式：**

第一种主从同步/复制的模式，当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。

哨兵模式是一种特殊的模式，首先 Redis 提供了哨兵的命令，**哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个 Redis 实例**。

<img src="Redis集群哨兵模式.png" alt="Redis集群哨兵模式.png" style="zoom: 50%;" />

然而一个哨兵进程对Redis服务器进行监控，也可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。

<img src="Redis集群多哨兵模式.png" alt="Redis集群多哨兵模式.png" style="zoom: 50%;" />

> 故障切换的过程：
>
> 假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行 failover 过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为**主观下线**。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行 failover 操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为**客观下线**。这样对于客户端而言，一切都是透明的。

作用：

+ 通过发送命令，让 Redis 服务器返回监控其运行状态，包括主服务器和从服务器；
+ 当哨兵监测到 master 宕机，会自动将 slave 切换成 master ，然后通过**发布订阅模式**通知其他的从服务器，修改配置文件，让它们切换主机；

哨兵模式的工作方式：

- 每个Sentinel（哨兵）进程以每秒钟一次的频率向整个集群中的 Master 主服务器，Slave 从服务器以及其他Sentinel（哨兵）进程发送一个 PING 命令。
- 如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel（哨兵）进程标记为主观下线（SDOWN）
- 如果一个 Master 主服务器被标记为主观下线（SDOWN），则正在监视这个 Master 主服务器的所有 Sentinel（哨兵）进程要以每秒一次的频率确认 Master 主服务器的确进入了主观下线状态
- 当有足够数量的 Sentinel（哨兵）进程（大于等于配置文件指定的值）在指定的时间范围内确认 Master 主服务器进入了主观下线状态（SDOWN）， 则 Master 主服务器会被标记为客观下线（ODOWN）
- 在一般情况下， 每个 Sentinel（哨兵）进程会以每 10 秒一次的频率向集群中的所有 Master 主服务器、Slave 从服务器发送 INFO 命令。
- 当 Master 主服务器被 Sentinel（哨兵）进程标记为客观下线（ODOWN）时，Sentinel（哨兵）进程向下线的 Master 主服务器的所有 Slave 从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。
- 若没有足够数量的 Sentinel（哨兵）进程同意 Master主服务器下线， Master 主服务器的客观下线状态就会被移除。若 Master 主服务器重新向 Sentinel（哨兵）进程发送 PING 命令返回有效回复，Master主服务器的主观下线状态就会被移除。

哨兵模式的优缺点：

优点：

- 哨兵模式是基于主从模式的，所有主从的优点，哨兵模式都具有。
- 主从可以自动切换，系统更健壮，可用性更高(**可以看作自动版的主从复制**)。

缺点：

- Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。

redis哨兵模式选举机制：

1. 故障节点主观下线
2. 故障节点客观下线
3. Sentinel集群选举Leader 
   + 节点确认主观下线就拉票
4. Sentinel Leader决定新主节点
   + 过滤故障的节点
   + 选择优先级`slave-priority`最大的从节点作为主节点，如不存在则继续
   + 选择复制偏移量（数据写入量的字节，记录写了多少数据。主服务器会把偏移量同步给从服务器，当主从的偏移量一致，则数据是完全同步）最大的从节点作为主节点，如不存在则继续
   + 选择`runid`（redis每次启动的时候生成随机的`runid`作为redis的标识）最小的从节点作为主节点

>  [redis哨兵模式选举机制](https://blog.csdn.net/LiaoHongHB/article/details/109092165){:target="_blank"}

**Cluster 集群模式（Redis官方）：**

Redis Cluster是一种服务器 Sharding 技术，3.0版本开始正式提供。

Redis 的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台 Redis 服务器都存储相同的数据，很浪费内存，所以在 redis3.0上加入了 Cluster 集群模式，实现了 Redis 的分布式存储，**也就是说每台 Redis 节点上存储不同的内容**

<img src="Redis集群Cluster集群模式.png" alt="Redis集群Cluster集群模式" style="zoom: 50%;" />

在这个图中，每一个蓝色的圈都代表着一个 redis 的服务器节点。它们任何两个节点之间都是相互连通的。客户端可以与任何一个节点相连接，然后就可以访问集群中的任何一个节点。对其进行存取和其他操作。

集群的数据分片：

Redis 集群没有使用一致性 hash，而是引入了哈希槽【hash slot】的概念。

Redis 集群有16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽。集群的每个节点负责一部分hash槽，举个例子，比如当前集群有3个节点，那么：

- 节点 A 包含 0 到 5460 号哈希槽
- 节点 B 包含 5461 到 10922 号哈希槽
- 节点 C 包含 10923 到 16383 号哈希槽

这种结构很容易添加或者删除节点。比如如果我想新添加个节点 D ， 我需要从节点 A， B， C 中得部分槽到 D 上。如果我想移除节点 A ，需要将 A 中的槽移到 B 和 C 节点上，然后将没有任何槽的 A 节点从集群中移除即可。由于从一个节点将哈希槽移动到另一个节点并不会停止服务，所以无论添加删除或者改变某个节点的哈希槽的数量都不会造成集群不可用的状态。

在 Redis 的每一个节点上，都有这么两个东西，一个是插槽（slot），它的的取值范围是：0-16383。还有一个就是 cluster，可以理解为是一个集群管理的插件。当我们的存取的 Key到达的时候，Redis 会根据 CRC16 的算法得出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作。

Redis 集群的主从复制模型：

为了保证高可用，redis-cluster集群引入了主从复制模型，一个主节点对应一个或者多个从节点，当主节点宕机的时候，就会启用从节点。当其它主节点 ping 一个主节点 A 时，如果半数以上的主节点与 A 通信超时，那么认为主节点 A 宕机了。如果主节点 A 和它的从节点 A1 都宕机了，那么该集群就无法再提供服务了。

集群的特点：

- 所有的 redis 节点彼此互联(PING-PONG机制)，内部使用二进制协议优化传输速度和带宽。
- 节点的 fail 是通过集群中超过半数的节点检测失效时才生效。
- 客户端与 Redis 节点直连，不需要中间代理层.客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。

> [你了解 Redis 的三种集群模式吗？](https://segmentfault.com/a/1190000022808576){:target="_blank"}

### 缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级

1. 缓存雪崩：

   问题描述：我们可以简单的理解为：由于原有缓存失效，新缓存未到期间 (例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃

   解决方法：大多数系统设计者考虑用加锁（最多的解决方案）或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。还有一个简单方案就时讲缓存失效时间分散开。

2. 缓存穿透：

   问题描述：缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题

   解决方法：最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴。5TB的硬盘上放满了数据，请写一个算法将这些数据进行排重。如果这些数据是一些32bit大小的数据该如何解决？如果是64bit的呢？对于空间的利用到达了一种极致，那就是Bitmap和布隆过滤器(Bloom Filter)。Bitmap：典型的就是哈希表缺点是，Bitmap对于每个元素只能记录1bit信息，如果还想完成额外的功能，恐怕只能靠牺牲更多的空间、时间来完成了

3. 缓存预热：

   问题描述：缓存预热这个应该是一个比较常见的概念，相信很多小伙伴都应该可以很容易的理解，缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据

   解决方法：1. 直接写个缓存刷新页面，上线时手工操作下； 2、数据量不大，可以在项目启动的时候自动进行加载； 3、定时刷新缓存；

4. 缓存更新：

   除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：（1）定时去清理过期的缓存；（2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡

5. 缓存降级：

   当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。以参考日志级别设置预案：（1）一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；（2）警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；（3）错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；（4）严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。
   服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户

> [缓存失效的场景](https://note.dolyw.com/cache/02-Cache-Invalidation.html#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F){:target="_blank"}

### 热点数据是怎么加载到缓存中的

1. 请求访问缓存，缓存没有则访问数据库，并同步写入缓存中
2. 通过 [淘汰机制](# Redis 淘汰策略有哪些？) 保证缓存中存放的都是热点数据 
3. 同时还需要保证 [双写的一致性](# 怎么保证缓存和数据库数据的双写一致性？) 

> + [缓存那些事 - 美团技术团队](https://tech.meituan.com/2017/03/17/cache-about.html){:target="_blank"}
> + [你所不知道的Redis热点问题以及如何发现热点](https://juejin.cn/post/6844903856011231239){:target="_blank"}
> + [缓存的万字总结，肝了！](https://zhuanlan.zhihu.com/p/337779755){:target="_blank"}

### 怎么保证缓存和数据库数据的双写一致性？

从理论上来说，给缓存设置过期时间，是可以保证最终一致性的解决方案

接下来的方案是保障缓存与数据库数据能尽可能的更快一致：

1. 先更新数据库，再更新缓存
2. 先更新缓存，再更新数据库
3. 先删除缓存，再更新数据库
4. 先更新数据库，再删除缓存

上面四种都有点问题，可以采用第三种或者第四种方案，然后加上**延时双删**

当**删除缓存这个操作失败**，上面的措施就会出问题，这时候可以提供一个重试机制：1）利用消息队列；2）利用中间件

+ 消息队列：缺点是对业务代码造成入侵

  <img src="redis延时双删改进消息队列.png" alt="消息队列" style="zoom: 50%;" />

  1. 更新数据库数据；
  2. 缓存因为种种问题删除失败
  3. 将需要删除的key发送至消息队列
  4. 自己消费消息，获得需要删除的key
  5. 继续重试删除操作，直到成功

+ 中间件：订阅binlog程序在mysql中有现成的中间件叫canal，可以完成订阅binlog日志的功能

  <img src="redis延时双删改进中间件.png" alt="中间件" style="zoom: 50%;" />

  1. 更新数据库数据
  2. 数据库会将操作信息写入binlog日志当中
  3. 订阅程序提取出所需要的数据以及key
  4. 另起一段非业务代码，获得该信息
  5. 尝试删除缓存操作，发现删除失败
  6. 将这些信息发送至消息队列
  7. 重新从消息队列中获得该数据，重试操作。

> - [Redis与数据库一致性](https://note.dolyw.com/cache/00-DataBaseConsistency.html#%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98-vs-%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98){:target="_blank"}
> - [【原创】分布式之数据库和缓存双写一致性方案解析 - 博客园](https://www.cnblogs.com/rjzheng/p/9041659.html){:target="_blank"}

### 缓存读写策略

1. 旁路缓存模式：比较适合读请求比较多的场景

   措施：先更新数据库，再删除缓存

   缺陷：

   1. 首次请求数据一定不在缓存中

      解决方法：热点数据提前放入缓存中

   2. 写操作比较频繁的话会导致缓存中的数据会被频繁的删除，影响缓存命中率

      解决方法：

      1. 数据库和缓存数据强一致性场景：更新数据库同时更新缓存，加分布式锁来保证更新缓存不存在线程安全问题
      2. 数据库和缓存数据弱一致性场景：更新数据库同时更新缓存，但是给缓存一个比较短的过期时间，这样保证即使数据不一致的话，影响也比较小

2. 读写穿透

   措施：

   1. 写：先查缓存，缓存不存在，直接更新数据库；缓存中存在，先更新缓存，再缓存服务更新数据库
   2. 读：从缓存中读取数据，读取到就直接返回；读取不到就先从数据库加载，写入缓存再返回响应

3. 异步缓存写入

   读写穿透不同的是，异步缓存写入则只更新缓存，不直接更新数据库，而是改为异步批量的方式来更新数据库

### Redis 持久化有几种方式？

Redis 的持久化有两种方式，或者说有两种策略：

- RDB（Redis Database）：指定的时间间隔能对数据进行快照存储，记录 redis 数据库的所有键值对，持久化结束后，用这个临时文件替换上次持久化的文件。

  - 优点
    1. 只有一个文件 dump.rdb ，方便持久化。 
    2. 容灾性好，一个文件可以保存到安全的磁盘。 
    3. 性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 Redis 的高性能 
    4. 相对于数据集大时，比 AOF 的启动效率更高。
  - 缺点
    1. 数据安全性低。 RDB 是间隔一段时间进行持久化，如果持久化之间 Redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候

- AOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中。

  - 优点

    1. 数据安全， AOF 持久化可以配置 appendfsync 属性，有 always，每进行一次命令操作就记录到 AOF 文件中一次。
    2. 通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据 一致性问题。
    3. AOF 机制的 rewrite 模式，创建一个新的 AOF 文件来代替原有的 AOF 文件， 新 AOF 文件和原有 AOF 文件保存的数据库状态完全一样， 但新 AOF 文件的体积小于等于原有 AOF 文件的体积

  - 缺点

    1. AOF 文件比 RDB 文件大，且恢复速度慢。
    2. 数据集大的时候，比 RDB 启动效率低。

    > [AOF — Redis 设计与实现](https://redisbook.readthedocs.io/en/latest/internal/aof.html){:target="_blank"}

### 持久化有两种，那应该怎么选择呢？

1. 不要仅仅使用 RDB ，因为那样会导致你丢失很多数据。 
2. 也不要仅仅使用 AOF ，因为那样有两个问题，第一，你通过 AOF 做冷备没有 RDB 做冷备的恢复速度更快; 第二， RDB 每次简单粗暴生成数据快照，更加健壮，可以避免 AOF 这种复杂的备份和恢复机制的 bug 。
3. Redis 支持同时开启开启两种持久化方式，我们可以综合使用 AOF 和 RDB 两种持久化机制，用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。
4. 如果同时使用 RDB 和 AOF 两种持久化机制，那么在 Redis 重启的时候，会使用 AOF 来重新构建数据，因为 AOF 中的数据更加完整。

### 什么情况下可能会导致 Redis 阻塞？

+ 内部原因
  1. 如果 Redis 主机的 CPU 负载过高，也会导致系统崩溃； 
  2. 数据持久化占用资源过多； 
  3. 对 Redis 的 API 或指令使用不合理，导致 Redis 出现问题。
+ 外部原因
  1. 外部原因主要是服务器的原因，例如服务器的 CPU 线程在切换过程中竞争过大，内存出现问题、网络问题等。

### 缓存和数据库谁先更新呢

+ 先删除缓存中的数据，再更新数据库，再更新缓存

+ 来了读请求，将读请求再次存入到缓存队列，保证等待队列前的写请求执行完成

+ 潜在问题
  + 请求时间过长，大量的写请求堆压在队列中，一个读请求来得等都写完了才可以获取到数据。
  + 读请求并发高

### 实现分布式锁的方式

1. 数据库锁：竞争表级资源和行级资源
2. zookeeper 分布式锁：竞争文件资源。每个请求的客户端随机生成一个 id，id 最小的获得资源，使用完就删除该 id
3. redis 的分布式锁：通过 setnx 竞争键值资源

> [几种分布式锁的实现方式](https://juejin.cn/post/6844903863363829767)

### Redis 怎么实现分布式锁？

Redis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。

占坑一般使用 setnx(set if not exists)指令，只允许被一个程序占有，使用完调用 del 释放锁。

> 扩展：[分布式锁的实现之 Redis 篇](https://xiaomi-info.github.io/2019/12/17/Redis-distributed-lock/){:target="_blank"}

### Redis 分布式锁有什么缺陷？

Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。

### Redis 如何做内存优化？

尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。

比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面。

### Redis 刷新策略

+ 过期删除策略（见下面问题）
+ 淘汰策略（见下面问题）
+ 主动刷新：开发控制生命周期

### Redis过期key是怎么清理的?

+ 过期删除策略

  1. 定时检查删除

     对于每一个设置了过期时间的 key 都会创建一个定时器，一旦达到过期时间都会删除。这种方式立即清除过期数据，对内存比较好，

     缺点：占用了大量 CPU 的资源去处理过期数据，会影响 redis 的吞吐量 和 响应时间。

  2. 惰性检查删除

     当访问一个 key 的时候，才会判断该 key 是否过期，如果过期就删除。该方式能最大限度节省 CPU 的资源。

     缺点：但是对内存不太好，有一种比较极端的情况：出现大量的过期 key 没有被再次访问，因为不会被清除，导致占用了大量的内存。

  3. 定期检查删除

     每隔一段时间，扫描redis 中过期key 的字典，并清除部分过期的key。这种方式是前俩种一种折中方法。不同的情况下，调整定时扫描时间间隔，让CPU 与 内存达到最优。

### Redis 淘汰策略有哪些？

- volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。
- volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。
- volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。
- allkeys-lru：从数据集（所有的key）（server. db[i]. dict）中挑选最近最少使用的数据淘汰。
- allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。
- allkeys-lfu 就是从所有的key中挑选使用频率最低的key，进行淘汰。
- no-enviction（驱逐）：禁止驱逐数据。

### Redis 常见的性能问题有哪些？该如何解决？

- 主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。
- Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。

> Reference:
>
> + <https://mp.weixin.qq.com/s/5I1Y77GN76h_OkVH1TisvA>{:target="_blank"}
---
layout: mypost
title: Redis
categories: [Java]
---



### Redis 是什么？都有哪些使用场景？

Redis 是一个开源的、基于内存、支持多种数据结构的存储系统，是个可持久化的日志型、Key-Value数据库，并提供多种语言的API，也可以作为缓存和消息中间件。

它支持的数据结构有字符串（strings）、哈希（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）等，除此之外还支持 bitmaps、hyperloglogs 和地理空间（ geospatial ）索引半径查询等功能。

Redis 使用场景：

- 数据高并发的读写
- 海量数据的读写
- 对扩展性要求高的数据

### Redis 有哪些功能？

- 数据缓存功能
- 分布式锁的功能
- 支持数据持久化
- 支持事务
- 支持消息队列

### Redis 和 memecache 有什么区别？

- memcached 所有的值均是简单的字符串，Redis作为其替代者，支持更为丰富的数据类型
- Redis 的速度比 memcached 快很多
- 存储数据安全– Memcache 挂掉后，数据没了； Redis 可以定期保存到磁盘（持久化）
- 灾难恢复– Memcache 挂掉后，数据不可恢复; Redis 数据丢失后可以通过 AOF 恢复

### Redis 为什么是单线程的？

因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。

关于 Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。

而且单线程并不代表就慢 nginx 和 nodejs 也都是高性能单线程的代表。

### 为什么Redis单线程模型效率也能那么高？

+ C语言实现，效率高 
+ 纯内存操作 
+ 基于非阻塞的IO复用模型机制 
+ 单线程的话就能避免多线程的频繁上下文切换问题 
+ 丰富的数据结构（全称采用hash结构，读取速度非常快，对数据存储进行了一些优化，比如压缩表，跳表等）

### 压缩表为什么可以节省内存

`ziplist` 虽然不维护前后节点的指针，但是它却维护了上一个节点的长度和当前节点的长度，然后每次通过长度来计算出前后节点的位置。

而在 `Redis` 中，一个指针是占了 `8` 个字节，但是大部分情况下，如果直接存储长度是达不到 `8` 个字节的，所以采用存储长度的设计方式在大部分场景下是可以节省内存空间的。

> [牺牲速度来节省内存，Redis是觉得自己太快了吗](https://zhuanlan.zhihu.com/p/344458785)

### Redis 有什么优点和缺点

+ 优点
  1. 速度快：因为数据存在内存中，类似于 HashMap ，HashMap 的优势就是查找和操作的时间复杂度都是O (1) 。
  
  2. 支持丰富的数据结构：支持 String ，List，Set，ZSet，Hash 五种基础的数据结构。
  
     > [Redis SDS的原理及与C字符串比较](https://codeleading.com/article/35214721883/)
     >
     > [C++中string类和Redis中SDS的比较](https://blog.csdn.net/wrx1721267632/article/details/50962370)
     >
     > [redis渐进式rehash机制](https://luoming1224.github.io/2018/11/12/[redis学习笔记]redis渐进式rehash机制/)
  
  3. 持久化存储：Redis 提供 RDB 和 AOF 两种数据的持久化存储方案，解决内存数据库最担心的万一 Redis 挂掉，数据会消失掉 
  
  4. 高可用：内置 Redis 哨兵，提供高可用方案，实现主从故障自动转移。 内置 Redis Cluster，提供集群方案，实现基于槽的分片方案，从而支持更大的 Redis 规模。 
  
  5. 丰富的特性：Key过期、计数、分布式锁、消息队列等。
+ 缺点
  1. 由于 Redis 是内存数据库，所以，单台机器，存储的数据量，跟机器本身的内存大小。虽然 Redis 本身有 Key 过期策略，但是还是需要提前预估和节约内存。如果内存增长过快，需要定期删除数据。
  2. 如果进行完整重同步，由于需要生成 RDB 文件，并进行传输，会占用主机的 CPU ，并会消耗现网的带宽。不过 Redis 2.8 版本，已经有部分重同步的功能，但是还是有可能有完整重同步的。比如，新上线的备机。
  3. 修改配置文件，进行重启，将硬盘中的数据加载进内存，时间比较久。在这个过程中， Redis 不能提供服务。

### 缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级

1. 缓存雪崩：

   问题描述：我们可以简单的理解为：由于原有缓存失效，新缓存未到期间 (例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃

   解决方法：大多数系统设计者考虑用加锁（最多的解决方案）或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。还有一个简单方案就时讲缓存失效时间分散开。

2. 缓存穿透：

   问题描述：缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题

   解决方法：最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴。5TB的硬盘上放满了数据，请写一个算法将这些数据进行排重。如果这些数据是一些32bit大小的数据该如何解决？如果是64bit的呢？对于空间的利用到达了一种极致，那就是Bitmap和布隆过滤器(Bloom Filter)。Bitmap：典型的就是哈希表缺点是，Bitmap对于每个元素只能记录1bit信息，如果还想完成额外的功能，恐怕只能靠牺牲更多的空间、时间来完成了

3. 缓存预热：

   问题描述：缓存预热这个应该是一个比较常见的概念，相信很多小伙伴都应该可以很容易的理解，缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据

   解决方法：1. 直接写个缓存刷新页面，上线时手工操作下； 2、数据量不大，可以在项目启动的时候自动进行加载； 3、定时刷新缓存；

4. 缓存更新：

   除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：（1）定时去清理过期的缓存；（2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡

5. 缓存降级：

   当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。以参考日志级别设置预案：（1）一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；（2）警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；（3）错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；（4）严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。
   服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户

### 怎么保证缓存和数据库数据的一致性？

- 合理设置缓存的过期时间。
- 新增、更改、删除数据库操作时同步更新 Redis，可以使用事务机制来保证数据的一致性。

### Redis 持久化有几种方式？

Redis 的持久化有两种方式，或者说有两种策略：

- RDB（Redis Database）：指定的时间间隔能对数据进行快照存储，记录 redis 数据库的所有键值对，持久化结束后，用这个临时文件替换上次持久化的文件。

  - 优点
    1. 只有一个文件 dump.rdb ，方便持久化。 
    2. 容灾性好，一个文件可以保存到安全的磁盘。 
    3. 性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 Redis 的高性能 
    4. 相对于数据集大时，比 AOF 的启动效率更高。
  - 缺点
    1. 数据安全性低。 RDB 是间隔一段时间进行持久化，如果持久化之间 Redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候

- AOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中。

  - 优点

    1. 数据安全， AOF 持久化可以配置 appendfsync 属性，有 always，每进行一次命令操作就记录到 AOF 文件中一次。
    2. 通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据 一致性问题。
    3. AOF 机制的 rewrite 模式，创建一个新的 AOF 文件来代替原有的 AOF 文件， 新 AOF 文件和原有 AOF 文件保存的数据库状态完全一样， 但新 AOF 文件的体积小于等于原有 AOF 文件的体积

  - 缺点

    1. AOF 文件比 RDB 文件大，且恢复速度慢。
    2. 数据集大的时候，比 RDB 启动效率低。

    > [AOF — Redis 设计与实现](https://redisbook.readthedocs.io/en/latest/internal/aof.html)

### 持久化有两种，那应该怎么选择呢？

1. 不要仅仅使用 RDB ，因为那样会导致你丢失很多数据。 
2. 也不要仅仅使用 AOF ，因为那样有两个问题，第一，你通过 AOF 做冷备没有 RDB 做冷备的恢复速度更快; 第二， RDB 每次简单粗暴生成数据快照，更加健壮，可以避免 AOF 这种复杂的备份和恢复机制的 bug 。
3. Redis 支持同时开启开启两种持久化方式，我们可以综合使用 AOF 和 RDB 两种持久化机制，用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。
4. 如果同时使用 RDB 和 AOF 两种持久化机制，那么在 Redis 重启的时候，会使用 AOF 来重新构建数据，因为 AOF 中的数据更加完整。

### 什么情况下可能会导致 Redis 阻塞？

+ 内部原因
  1. 如果 Redis 主机的 CPU 负载过高，也会导致系统崩溃； 
  2. 数据持久化占用资源过多； 
  3. 对 Redis 的 API 或指令使用不合理，导致 Redis 出现问题。
+ 外部原因
  1. 外部原因主要是服务器的原因，例如服务器的 CPU 线程在切换过程中竞争过大，内存出现问题、网络问题等。

### 缓存和数据库谁先更新呢

+ 先删除缓存中的数据，再更新数据库，再更新缓存

+ 来了读请求，将读请求再次存入到缓存队列，保证等待队列前的写请求执行完成

+ 潜在问题
  + 请求时间过长，大量的写请求堆压在队列中，一个读请求来得等都写完了才可以获取到数据。
  + 读请求并发高

### Redis 怎么实现分布式锁？

Redis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。

占坑一般使用 setnx(set if not exists)指令，只允许被一个程序占有，使用完调用 del 释放锁。

> 扩展：[分布式锁的实现之 Redis 篇](https://xiaomi-info.github.io/2019/12/17/Redis-distributed-lock/)

### Redis 分布式锁有什么缺陷？

Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。

### Redis 如何做内存优化？

尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。

比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面。

### Redis 刷新策略

+ 过期删除策略（见下面问题）
+ 淘汰策略（见下面问题）
+ 主动刷新：开发控制生命周期

### Redis过期key是怎么清理的?

+ 过期删除策略

  1. 定时检查删除

     对于每一个设置了过期时间的 key 都会创建一个定时器，一旦达到过期时间都会删除。这种方式立即清除过期数据，对内存比较好，

     缺点：占用了大量 CPU 的资源去处理过期数据，会影响 redis 的吞吐量 和 响应时间。

  2. 惰性检查删除

     当访问一个 key 的时候，才会判断该 key 是否过期，如果过期就删除。该方式能最大限度节省 CPU 的资源。

     缺点：但是对内存不太好，有一种比较极端的情况：出现大量的过期 key 没有被再次访问，因为不会被清除，导致占用了大量的内存。

  3. 定期检查删除

     每隔一段时间，扫描redis 中过期key 的字典，并清除部分过期的key。这种方式是前俩种一种折中方法。不同的情况下，调整定时扫描时间间隔，让CPU 与 内存达到最优。


### Redis 淘汰策略有哪些？

- volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。
- volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。
- volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。
- allkeys-lru：从数据集（所有的key）（server. db[i]. dict）中挑选最近最少使用的数据淘汰。
- allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。
- allkeys-lfu 就是从所有的key中挑选使用频率最低的key，进行淘汰。
- no-enviction（驱逐）：禁止驱逐数据。

### Redis 常见的性能问题有哪些？该如何解决？

- 主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。
- Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。

> Reference:
>
> + https://mp.weixin.qq.com/s/5I1Y77GN76h_OkVH1TisvA
---
layout: mypost
title: Redis
categories: [Java]
---



### Redis 是什么？都有哪些使用场景？

Redis 是一个开源的、基于内存、支持多种数据结构的存储系统，是个可持久化的日志型、Key-Value数据库，并提供多种语言的API，也可以作为缓存和消息中间件。

它支持的数据结构有字符串（strings）、哈希（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）等，除此之外还支持 bitmaps、hyperloglogs 和地理空间（ geospatial ）索引半径查询等功能。

Redis 使用场景：

- 数据高并发的读写
- 海量数据的读写
- 对扩展性要求高的数据

### Redis 有哪些功能？

- 数据缓存功能
- 分布式锁的功能
- 支持数据持久化
- 支持事务
- 支持消息队列

### Redis 和 memecache 有什么区别？

- memcached 所有的值均是简单的字符串，Redis作为其替代者，支持更为丰富的数据类型
- Redis 的速度比 memcached 快很多
- 存储数据安全– Memcache 挂掉后，数据没了； Redis 可以定期保存到磁盘（持久化）
- 灾难恢复– Memcache 挂掉后，数据不可恢复; Redis 数据丢失后可以通过 AOF 恢复

### Redis 为什么是单线程的？

因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。

关于 Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。

而且单线程并不代表就慢 nginx 和 nodejs 也都是高性能单线程的代表。

### 为什么Redis单线程模型效率也能那么高？

+ C语言实现，效率高 
+ 纯内存操作 
+ 基于非阻塞的IO复用模型机制 
+ 单线程的话就能避免多线程的频繁上下文切换问题 
+ 丰富的数据结构（全称采用hash结构，读取速度非常快，对数据存储进行了一些优化，比如压缩表，跳表等）

### 压缩表为什么可以节省内存

`ziplist` 虽然不维护前后节点的指针，但是它却维护了上一个节点的长度和当前节点的长度，然后每次通过长度来计算出前后节点的位置。

而在 `Redis` 中，一个指针是占了 `8` 个字节，但是大部分情况下，如果直接存储长度是达不到 `8` 个字节的，所以采用存储长度的设计方式在大部分场景下是可以节省内存空间的。

> [牺牲速度来节省内存，Redis是觉得自己太快了吗](https://zhuanlan.zhihu.com/p/344458785)

### Redis 有什么优点和缺点

+ 优点
  1. 速度快：因为数据存在内存中，类似于 HashMap ，HashMap 的优势就是查找和操作的时间复杂度都是O (1) 。
  
  2. 支持丰富的数据结构：支持 String ，List，Set，ZSet，Hash 五种基础的数据结构。
  
     > [Redis SDS的原理及与C字符串比较](https://codeleading.com/article/35214721883/)
     >
     > [C++中string类和Redis中SDS的比较](https://blog.csdn.net/wrx1721267632/article/details/50962370)
     >
     > [redis渐进式rehash机制](https://luoming1224.github.io/2018/11/12/[redis学习笔记]redis渐进式rehash机制/)
  
  3. 持久化存储：Redis 提供 RDB 和 AOF 两种数据的持久化存储方案，解决内存数据库最担心的万一 Redis 挂掉，数据会消失掉 
  
  4. 高可用：内置 Redis 哨兵，提供高可用方案，实现主从故障自动转移。 内置 Redis Cluster，提供集群方案，实现基于槽的分片方案，从而支持更大的 Redis 规模。 
  
  5. 丰富的特性：Key过期、计数、分布式锁、消息队列等。
+ 缺点
  1. 由于 Redis 是内存数据库，所以，单台机器，存储的数据量，跟机器本身的内存大小。虽然 Redis 本身有 Key 过期策略，但是还是需要提前预估和节约内存。如果内存增长过快，需要定期删除数据。
  2. 如果进行完整重同步，由于需要生成 RDB 文件，并进行传输，会占用主机的 CPU ，并会消耗现网的带宽。不过 Redis 2.8 版本，已经有部分重同步的功能，但是还是有可能有完整重同步的。比如，新上线的备机。
  3. 修改配置文件，进行重启，将硬盘中的数据加载进内存，时间比较久。在这个过程中， Redis 不能提供服务。

### 缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级

缓存穿透：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。

解决方案：最简单粗暴的方法如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。

### 怎么保证缓存和数据库数据的一致性？

- 合理设置缓存的过期时间。
- 新增、更改、删除数据库操作时同步更新 Redis，可以使用事务机制来保证数据的一致性。

### Redis 持久化有几种方式？

Redis 的持久化有两种方式，或者说有两种策略：

- RDB（Redis Database）：指定的时间间隔能对数据进行快照存储，记录 redis 数据库的所有键值对，持久化结束后，用这个临时文件替换上次持久化的文件。

  - 优点
    1. 只有一个文件 dump.rdb ，方便持久化。 
    2. 容灾性好，一个文件可以保存到安全的磁盘。 
    3. 性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 Redis 的高性能 
    4. 相对于数据集大时，比 AOF 的启动效率更高。
  - 缺点
    1. 数据安全性低。 RDB 是间隔一段时间进行持久化，如果持久化之间 Redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候

- AOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中。

  - 优点

    1. 数据安全， AOF 持久化可以配置 appendfsync 属性，有 always，每进行一次命令操作就记录到 AOF 文件中一次。
    2. 通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据 一致性问题。
    3. AOF 机制的 rewrite 模式，创建一个新的 AOF 文件来代替原有的 AOF 文件， 新 AOF 文件和原有 AOF 文件保存的数据库状态完全一样， 但新 AOF 文件的体积小于等于原有 AOF 文件的体积

  - 缺点

    1. AOF 文件比 RDB 文件大，且恢复速度慢。
    2. 数据集大的时候，比 RDB 启动效率低。

    > [AOF — Redis 设计与实现](https://redisbook.readthedocs.io/en/latest/internal/aof.html)

### 持久化有两种，那应该怎么选择呢？

1. 不要仅仅使用 RDB ，因为那样会导致你丢失很多数据。 
2. 也不要仅仅使用 AOF ，因为那样有两个问题，第一，你通过 AOF 做冷备没有 RDB 做冷备的恢复速度更快; 第二， RDB 每次简单粗暴生成数据快照，更加健壮，可以避免 AOF 这种复杂的备份和恢复机制的 bug 。
3. Redis 支持同时开启开启两种持久化方式，我们可以综合使用 AOF 和 RDB 两种持久化机制，用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。
4. 如果同时使用 RDB 和 AOF 两种持久化机制，那么在 Redis 重启的时候，会使用 AOF 来重新构建数据，因为 AOF 中的数据更加完整。

### 什么情况下可能会导致 Redis 阻塞？

+ 内部原因
  1. 如果 Redis 主机的 CPU 负载过高，也会导致系统崩溃； 
  2. 数据持久化占用资源过多； 
  3. 对 Redis 的 API 或指令使用不合理，导致 Redis 出现问题。
+ 外部原因
  1. 外部原因主要是服务器的原因，例如服务器的 CPU 线程在切换过程中竞争过大，内存出现问题、网络问题等。

### 缓存和数据库谁先更新呢

+ 先删除缓存中的数据，再更新数据库，再更新缓存

+ 来了读请求，将读请求再次存入到缓存队列，保证等待队列前的写请求执行完成

+ 潜在问题
  + 请求时间过长，大量的写请求堆压在队列中，一个读请求来得等都写完了才可以获取到数据。
  + 读请求并发高

### Redis 怎么实现分布式锁？

Redis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。

占坑一般使用 setnx(set if not exists)指令，只允许被一个程序占有，使用完调用 del 释放锁。

> 扩展：[分布式锁的实现之 Redis 篇](https://xiaomi-info.github.io/2019/12/17/Redis-distributed-lock/)

### Redis 分布式锁有什么缺陷？

Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。

### Redis 如何做内存优化？

尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。

比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面。

### Redis过期key是怎么清理的?

+ 过期删除策略

  1. 定时检查删除

     对于每一个设置了过期时间的 key 都会创建一个定时器，一旦达到过期时间都会删除。这种方式立即清除过期数据，对内存比较好，

     缺点：占用了大量 CPU 的资源去处理过期数据，会影响 redis 的吞吐量 和 响应时间。

  2. 惰性检查删除

     当访问一个 key 的时候，才会判断该 key 是否过期，如果过期就删除。该方式能最大限度节省 CPU 的资源。

     缺点：但是对内存不太好，有一种比较极端的情况：出现大量的过期 key 没有被再次访问，因为不会被清除，导致占用了大量的内存。

  3. 定期检查删除

     每隔一段时间，扫描redis 中过期key 的字典，并清除部分过期的key。这种方式是前俩种一种折中方法。不同的情况下，调整定时扫描时间间隔，让CPU 与 内存达到最优。

+ 内存淘汰策略

### Redis 淘汰策略有哪些？

- volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。
- volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。
- volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。
- allkeys-lru：从数据集（所有的key）（server. db[i]. dict）中挑选最近最少使用的数据淘汰。
- allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。
- allkeys-lfu 就是从所有的key中挑选使用频率最低的key，进行淘汰。
- no-enviction（驱逐）：禁止驱逐数据。

### Redis 常见的性能问题有哪些？该如何解决？

- 主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。
- Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。

> Reference:
>
> + https://mp.weixin.qq.com/s/5I1Y77GN76h_OkVH1TisvA